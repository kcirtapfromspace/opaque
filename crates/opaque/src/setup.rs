//! Config generation from setup wizard answers.
//!
//! Produces a valid `config.toml` from the user's choices during
//! interactive onboarding.

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/// Collected answers from the interactive setup wizard.
pub struct SetupAnswers {
    pub human_clients: Vec<HumanClientConfig>,
    pub enabled_operations: Vec<EnabledOperation>,
    pub require_biometric: bool,
    pub lease_ttl: u64,
}

/// A human client to register in the config.
pub struct HumanClientConfig {
    pub name: String,
    pub exe_path: String,
}

/// Operations that can be enabled via the wizard.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[allow(dead_code)]
pub enum EnabledOperation {
    OnePassword,
    GitHub,
    Sandbox,
    TestNoop,
}

impl EnabledOperation {
    /// All operations available in the wizard.
    pub const ALL: &'static [EnabledOperation] = &[
        EnabledOperation::OnePassword,
        EnabledOperation::GitHub,
        EnabledOperation::Sandbox,
    ];

    /// Display label for the wizard multi-select.
    pub fn label(self) -> &'static str {
        match self {
            EnabledOperation::OnePassword => "1Password (list vaults, list items, read fields)",
            EnabledOperation::GitHub => "GitHub (set, list, delete secrets)",
            EnabledOperation::Sandbox => "Sandbox execution (run profiles)",
            EnabledOperation::TestNoop => "Test no-op (development)",
        }
    }
}

// ---------------------------------------------------------------------------
// Config generation
// ---------------------------------------------------------------------------

/// Generate `config.toml` content from wizard answers.
pub fn generate_config(answers: &SetupAnswers) -> String {
    let mut out = String::new();

    out.push_str("# Opaque configuration file\n");
    out.push_str("# Generated by `opaque setup`.\n");
    out.push_str("#\n");
    out.push_str("# This config is sealed â€” any modification will break the seal.\n");
    out.push_str("# Run `opaque setup --reset` to unseal before editing.\n\n");

    // Human clients
    for client in &answers.human_clients {
        out.push_str("[[known_human_clients]]\n");
        out.push_str(&format!("name = {:?}\n", client.name));
        out.push_str(&format!("exe_path = {:?}\n", client.exe_path));
        out.push('\n');
    }

    // Rules for each enabled operation
    let approval_require = if answers.require_biometric {
        "first_use"
    } else {
        "never"
    };
    let factors = if answers.require_biometric {
        "[\"local_bio\"]"
    } else {
        "[]"
    };

    for op in &answers.enabled_operations {
        match op {
            EnabledOperation::OnePassword => {
                write_rule(
                    &mut out,
                    "allow-onepassword-list-vaults",
                    "onepassword.list_vaults",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-onepassword-list-items",
                    "onepassword.list_items",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-onepassword-read-field",
                    "onepassword.read_field",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
            }
            EnabledOperation::GitHub => {
                write_rule(
                    &mut out,
                    "allow-github-set-actions-secret",
                    "github.set_actions_secret",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-github-set-codespaces-secret",
                    "github.set_codespaces_secret",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-github-set-dependabot-secret",
                    "github.set_dependabot_secret",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-github-set-org-secret",
                    "github.set_org_secret",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-github-list-secrets",
                    "github.list_secrets",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
                write_rule(
                    &mut out,
                    "allow-github-delete-secret",
                    "github.delete_secret",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
            }
            EnabledOperation::Sandbox => {
                write_rule(
                    &mut out,
                    "allow-sandbox-exec",
                    "sandbox.exec",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
            }
            EnabledOperation::TestNoop => {
                write_rule(
                    &mut out,
                    "allow-test-noop",
                    "test.noop",
                    approval_require,
                    factors,
                    answers.lease_ttl,
                );
            }
        }
    }

    out
}

fn write_rule(
    out: &mut String,
    name: &str,
    operation_pattern: &str,
    approval_require: &str,
    factors: &str,
    lease_ttl: u64,
) {
    out.push_str("[[rules]]\n");
    out.push_str(&format!("name = {name:?}\n"));
    out.push_str(&format!("operation_pattern = {operation_pattern:?}\n"));
    out.push_str("allow = true\n");
    out.push_str("client_types = [\"human\"]\n");
    out.push('\n');
    out.push_str("[rules.client]\n\n");
    out.push_str("[rules.target]\nfields = {}\n\n");
    out.push_str("[rules.workspace]\n\n");
    out.push_str("[rules.secret_names]\n\n");
    out.push_str("[rules.approval]\n");
    out.push_str(&format!("require = {approval_require:?}\n"));
    out.push_str(&format!("factors = {factors}\n"));
    if lease_ttl > 0 && approval_require != "never" {
        out.push_str(&format!("lease_ttl = {lease_ttl}\n"));
    }
    out.push('\n');
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_config_basic() {
        let answers = SetupAnswers {
            human_clients: vec![HumanClientConfig {
                name: "opaque-cli".into(),
                exe_path: "/usr/bin/opaque".into(),
            }],
            enabled_operations: vec![EnabledOperation::OnePassword],
            require_biometric: true,
            lease_ttl: 300,
        };

        let config = generate_config(&answers);
        assert!(config.contains("[[known_human_clients]]"));
        assert!(config.contains("name = \"opaque-cli\""));
        assert!(config.contains("exe_path = \"/usr/bin/opaque\""));
        assert!(config.contains("allow-onepassword-list-vaults"));
        assert!(config.contains("allow-onepassword-list-items"));
        assert!(config.contains("allow-onepassword-read-field"));
        assert!(config.contains("require = \"first_use\""));
        assert!(config.contains("[\"local_bio\"]"));
        assert!(config.contains("lease_ttl = 300"));
    }

    #[test]
    fn generate_config_no_biometric() {
        let answers = SetupAnswers {
            human_clients: vec![],
            enabled_operations: vec![EnabledOperation::TestNoop],
            require_biometric: false,
            lease_ttl: 0,
        };

        let config = generate_config(&answers);
        assert!(config.contains("require = \"never\""));
        assert!(config.contains("factors = []"));
        assert!(!config.contains("lease_ttl"));
    }

    #[test]
    fn generate_config_github_creates_all_rules() {
        let answers = SetupAnswers {
            human_clients: vec![],
            enabled_operations: vec![EnabledOperation::GitHub],
            require_biometric: true,
            lease_ttl: 600,
        };

        let config = generate_config(&answers);
        assert!(config.contains("allow-github-set-actions-secret"));
        assert!(config.contains("allow-github-set-codespaces-secret"));
        assert!(config.contains("allow-github-set-dependabot-secret"));
        assert!(config.contains("allow-github-set-org-secret"));
        assert!(config.contains("allow-github-list-secrets"));
        assert!(config.contains("allow-github-delete-secret"));
    }

    #[test]
    fn generate_config_multiple_clients() {
        let answers = SetupAnswers {
            human_clients: vec![
                HumanClientConfig {
                    name: "cli-1".into(),
                    exe_path: "/usr/bin/opaque".into(),
                },
                HumanClientConfig {
                    name: "cli-2".into(),
                    exe_path: "/opt/bin/opaque".into(),
                },
            ],
            enabled_operations: vec![],
            require_biometric: false,
            lease_ttl: 0,
        };

        let config = generate_config(&answers);
        // Should have two [[known_human_clients]] blocks.
        assert_eq!(config.matches("[[known_human_clients]]").count(), 2);
    }

    #[test]
    fn generate_config_parses_as_valid_toml() {
        let answers = SetupAnswers {
            human_clients: vec![HumanClientConfig {
                name: "test-cli".into(),
                exe_path: "/usr/bin/test".into(),
            }],
            enabled_operations: vec![
                EnabledOperation::OnePassword,
                EnabledOperation::GitHub,
                EnabledOperation::Sandbox,
            ],
            require_biometric: true,
            lease_ttl: 300,
        };

        let config = generate_config(&answers);
        // Should parse without errors.
        let parsed: toml_edit::DocumentMut = config
            .parse()
            .expect("generated config should be valid TOML");
        assert!(!parsed.is_empty());
    }

    #[test]
    fn enabled_operation_labels() {
        for op in EnabledOperation::ALL {
            assert!(!op.label().is_empty());
        }
    }
}
